import {
  require_vue
} from "./chunk-IWBKCIK5.js";
import "./chunk-32Y5UOOH.js";
import {
  __commonJS,
  __esm,
  __toCommonJS
} from "./chunk-ROME4SDB.js";

// node_modules/vue3-draggable-resizable/src/components/utils.js
var require_utils = __commonJS({
  "node_modules/vue3-draggable-resizable/src/components/utils.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    exports.__esModule = true;
    exports.getReferenceLineMap = exports.getId = exports.filterHandles = exports.removeEvent = exports.addEvent = exports.getElSize = exports.IDENTITY = void 0;
    var Vue3DraggableResizable_1 = require_Vue3DraggableResizable();
    exports.IDENTITY = Symbol("Vue3DraggableResizable");
    function getElSize(el) {
      var style = window.getComputedStyle(el);
      return {
        width: parseFloat(style.getPropertyValue("width")),
        height: parseFloat(style.getPropertyValue("height"))
      };
    }
    exports.getElSize = getElSize;
    function createEventListenerFunction(type) {
      return function(el, events, handler) {
        if (!el) {
          return;
        }
        if (typeof events === "string") {
          events = [events];
        }
        events.forEach(function(e) {
          return el[type](e, handler, { passive: false });
        });
      };
    }
    exports.addEvent = createEventListenerFunction("addEventListener");
    exports.removeEvent = createEventListenerFunction("removeEventListener");
    function filterHandles(handles) {
      if (handles && handles.length > 0) {
        var result_1 = [];
        handles.forEach(function(item) {
          if (Vue3DraggableResizable_1.ALL_HANDLES.includes(item) && !result_1.includes(item)) {
            result_1.push(item);
          }
        });
        return result_1;
      } else {
        return [];
      }
    }
    exports.filterHandles = filterHandles;
    function getId() {
      return String(Math.random()).substr(2) + String(Date.now());
    }
    exports.getId = getId;
    function getReferenceLineMap(containerProvider, parentSize, id) {
      var _a, _b;
      if (containerProvider.disabled.value) {
        return null;
      }
      var referenceLine = {
        row: [],
        col: []
      };
      var parentWidth = parentSize.parentWidth, parentHeight = parentSize.parentHeight;
      (_a = referenceLine.row).push.apply(_a, containerProvider.adsorbRows);
      (_b = referenceLine.col).push.apply(_b, containerProvider.adsorbCols);
      if (containerProvider.adsorbParent.value) {
        referenceLine.row.push(0, parentHeight.value, parentHeight.value / 2);
        referenceLine.col.push(0, parentWidth.value, parentWidth.value / 2);
      }
      var widgetPositionStore = containerProvider.getPositionStore(id);
      Object.values(widgetPositionStore).forEach(function(_a2) {
        var x = _a2.x, y = _a2.y, w = _a2.w, h = _a2.h;
        referenceLine.row.push(y, y + h, y + h / 2);
        referenceLine.col.push(x, x + w, x + w / 2);
      });
      var referenceLineMap = {
        row: referenceLine.row.reduce(function(pre, cur) {
          var _a2;
          return __assign(__assign({}, pre), (_a2 = {}, _a2[cur] = { min: cur - 5, max: cur + 5, value: cur }, _a2));
        }, {}),
        col: referenceLine.col.reduce(function(pre, cur) {
          var _a2;
          return __assign(__assign({}, pre), (_a2 = {}, _a2[cur] = { min: cur - 5, max: cur + 5, value: cur }, _a2));
        }, {})
      };
      return referenceLineMap;
    }
    exports.getReferenceLineMap = getReferenceLineMap;
  }
});

// node_modules/vue3-draggable-resizable/src/components/hooks.js
var require_hooks = __commonJS({
  "node_modules/vue3-draggable-resizable/src/components/hooks.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    exports.__esModule = true;
    exports.watchProps = exports.initResizeHandle = exports.initDraggableContainer = exports.initLimitSizeAndMethods = exports.initParent = exports.initState = exports.useState = void 0;
    var vue_1 = require_vue();
    var utils_1 = require_utils();
    function useState(initialState) {
      var state = vue_1.ref(initialState);
      var setState = function(value) {
        state.value = value;
        return value;
      };
      return [state, setState];
    }
    exports.useState = useState;
    function initState(props, emit) {
      var _a = useState(props.initW), width = _a[0], setWidth = _a[1];
      var _b = useState(props.initH), height = _b[0], setHeight = _b[1];
      var _c = useState(props.x), left = _c[0], setLeft = _c[1];
      var _d = useState(props.y), top = _d[0], setTop = _d[1];
      var _e = useState(props.active), enable = _e[0], setEnable = _e[1];
      var _f = useState(false), dragging = _f[0], setDragging = _f[1];
      var _g = useState(false), resizing = _g[0], setResizing = _g[1];
      var _h = useState(""), resizingHandle = _h[0], setResizingHandle = _h[1];
      var _j = useState(Infinity), resizingMaxWidth = _j[0], setResizingMaxWidth = _j[1];
      var _k = useState(Infinity), resizingMaxHeight = _k[0], setResizingMaxHeight = _k[1];
      var _l = useState(props.minW), resizingMinWidth = _l[0], setResizingMinWidth = _l[1];
      var _m = useState(props.minH), resizingMinHeight = _m[0], setResizingMinHeight = _m[1];
      var aspectRatio = vue_1.computed(function() {
        return height.value / width.value;
      });
      vue_1.watch(width, function(newVal) {
        emit("update:w", newVal);
      }, { immediate: true });
      vue_1.watch(height, function(newVal) {
        emit("update:h", newVal);
      }, { immediate: true });
      vue_1.watch(top, function(newVal) {
        emit("update:y", newVal);
      });
      vue_1.watch(left, function(newVal) {
        emit("update:x", newVal);
      });
      vue_1.watch(enable, function(newVal, oldVal) {
        emit("update:active", newVal);
        if (!oldVal && newVal) {
          emit("activated");
        } else if (oldVal && !newVal) {
          emit("deactivated");
        }
      });
      vue_1.watch(function() {
        return props.active;
      }, function(newVal) {
        setEnable(newVal);
      });
      return {
        id: utils_1.getId(),
        width,
        height,
        top,
        left,
        enable,
        dragging,
        resizing,
        resizingHandle,
        resizingMaxHeight,
        resizingMaxWidth,
        resizingMinWidth,
        resizingMinHeight,
        aspectRatio,
        setEnable,
        setDragging,
        setResizing,
        setResizingHandle,
        setResizingMaxHeight,
        setResizingMaxWidth,
        setResizingMinWidth,
        setResizingMinHeight,
        setWidth: function(val) {
          return setWidth(Math.floor(val));
        },
        setHeight: function(val) {
          return setHeight(Math.floor(val));
        },
        setTop: function(val) {
          return setTop(Math.floor(val));
        },
        setLeft: function(val) {
          return setLeft(Math.floor(val));
        }
      };
    }
    exports.initState = initState;
    function initParent(containerRef) {
      var parentWidth = vue_1.ref(0);
      var parentHeight = vue_1.ref(0);
      vue_1.onMounted(function() {
        if (containerRef.value && containerRef.value.parentElement) {
          var _a = utils_1.getElSize(containerRef.value.parentElement), width = _a.width, height = _a.height;
          parentWidth.value = width;
          parentHeight.value = height;
        }
      });
      return {
        parentWidth,
        parentHeight
      };
    }
    exports.initParent = initParent;
    function initLimitSizeAndMethods(props, parentSize, containerProps) {
      var width = containerProps.width, height = containerProps.height, left = containerProps.left, top = containerProps.top, resizingMaxWidth = containerProps.resizingMaxWidth, resizingMaxHeight = containerProps.resizingMaxHeight, resizingMinWidth = containerProps.resizingMinWidth, resizingMinHeight = containerProps.resizingMinHeight;
      var setWidth = containerProps.setWidth, setHeight = containerProps.setHeight, setTop = containerProps.setTop, setLeft = containerProps.setLeft;
      var parentWidth = parentSize.parentWidth, parentHeight = parentSize.parentHeight;
      var limitProps = {
        minWidth: vue_1.computed(function() {
          return resizingMinWidth.value;
        }),
        minHeight: vue_1.computed(function() {
          return resizingMinHeight.value;
        }),
        maxWidth: vue_1.computed(function() {
          var max = Infinity;
          if (props.parent) {
            max = Math.min(parentWidth.value, resizingMaxWidth.value);
          }
          return max;
        }),
        maxHeight: vue_1.computed(function() {
          var max = Infinity;
          if (props.parent) {
            max = Math.min(parentHeight.value, resizingMaxHeight.value);
          }
          return max;
        }),
        minLeft: vue_1.computed(function() {
          return props.parent ? 0 : -Infinity;
        }),
        minTop: vue_1.computed(function() {
          return props.parent ? 0 : -Infinity;
        }),
        maxLeft: vue_1.computed(function() {
          return props.parent ? parentWidth.value - width.value : Infinity;
        }),
        maxTop: vue_1.computed(function() {
          return props.parent ? parentHeight.value - height.value : Infinity;
        })
      };
      var limitMethods = {
        setWidth: function(val) {
          if (props.disabledW) {
            return width.value;
          }
          return setWidth(Math.min(limitProps.maxWidth.value, Math.max(limitProps.minWidth.value, val)));
        },
        setHeight: function(val) {
          if (props.disabledH) {
            return height.value;
          }
          return setHeight(Math.min(limitProps.maxHeight.value, Math.max(limitProps.minHeight.value, val)));
        },
        setTop: function(val) {
          if (props.disabledY) {
            return top.value;
          }
          return setTop(Math.min(limitProps.maxTop.value, Math.max(limitProps.minTop.value, val)));
        },
        setLeft: function(val) {
          if (props.disabledX) {
            return left.value;
          }
          return setLeft(Math.min(limitProps.maxLeft.value, Math.max(limitProps.minLeft.value, val)));
        }
      };
      return __assign(__assign({}, limitProps), limitMethods);
    }
    exports.initLimitSizeAndMethods = initLimitSizeAndMethods;
    var DOWN_HANDLES = ["mousedown", "touchstart"];
    var UP_HANDLES = ["mouseup", "touchend"];
    var MOVE_HANDLES = ["mousemove", "touchmove"];
    function getPosition(e) {
      if ("touches" in e) {
        return [e.touches[0].pageX, e.touches[0].pageY];
      } else {
        return [e.pageX, e.pageY];
      }
    }
    function initDraggableContainer(containerRef, containerProps, limitProps, draggable, emit, containerProvider, parentSize) {
      var x = containerProps.left, y = containerProps.top, w = containerProps.width, h = containerProps.height, dragging = containerProps.dragging, id = containerProps.id;
      var setDragging = containerProps.setDragging, setEnable = containerProps.setEnable, setResizing = containerProps.setResizing, setResizingHandle = containerProps.setResizingHandle;
      var setTop = limitProps.setTop, setLeft = limitProps.setLeft;
      var lstX = 0;
      var lstY = 0;
      var lstPageX = 0;
      var lstPageY = 0;
      var referenceLineMap = null;
      var documentElement = document.documentElement;
      var _unselect = function(e) {
        var _a;
        var target = e.target;
        if (!((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(target))) {
          setEnable(false);
          setDragging(false);
          setResizing(false);
          setResizingHandle("");
        }
      };
      var handleUp = function() {
        setDragging(false);
        utils_1.removeEvent(documentElement, UP_HANDLES, handleUp);
        utils_1.removeEvent(documentElement, MOVE_HANDLES, handleDrag);
        referenceLineMap = null;
        if (containerProvider) {
          containerProvider.updatePosition(id, {
            x: x.value,
            y: y.value,
            w: w.value,
            h: h.value
          });
          containerProvider.setMatchedLine(null);
        }
      };
      var handleDrag = function(e) {
        e.preventDefault();
        if (!(dragging.value && containerRef.value))
          return;
        var _a = getPosition(e), pageX = _a[0], pageY = _a[1];
        var deltaX = pageX - lstPageX;
        var deltaY = pageY - lstPageY;
        var newLeft = lstX + deltaX;
        var newTop = lstY + deltaY;
        if (referenceLineMap !== null) {
          var widgetSelfLine = {
            col: [newLeft, newLeft + w.value / 2, newLeft + w.value],
            row: [newTop, newTop + h.value / 2, newTop + h.value]
          };
          var matchedLine = {
            row: widgetSelfLine.row.map(function(i, index) {
              var match = null;
              Object.values(referenceLineMap.row).forEach(function(referItem) {
                if (i >= referItem.min && i <= referItem.max) {
                  match = referItem.value;
                }
              });
              if (match !== null) {
                if (index === 0) {
                  newTop = match;
                } else if (index === 1) {
                  newTop = Math.floor(match - h.value / 2);
                } else if (index === 2) {
                  newTop = Math.floor(match - h.value);
                }
              }
              return match;
            }).filter(function(i) {
              return i !== null;
            }),
            col: widgetSelfLine.col.map(function(i, index) {
              var match = null;
              Object.values(referenceLineMap.col).forEach(function(referItem) {
                if (i >= referItem.min && i <= referItem.max) {
                  match = referItem.value;
                }
              });
              if (match !== null) {
                if (index === 0) {
                  newLeft = match;
                } else if (index === 1) {
                  newLeft = Math.floor(match - w.value / 2);
                } else if (index === 2) {
                  newLeft = Math.floor(match - w.value);
                }
              }
              return match;
            }).filter(function(i) {
              return i !== null;
            })
          };
          containerProvider.setMatchedLine(matchedLine);
        }
        emit("dragging", { x: setLeft(newLeft), y: setTop(newTop) });
      };
      var handleDown = function(e) {
        if (!draggable.value)
          return;
        setDragging(true);
        lstX = x.value;
        lstY = y.value;
        lstPageX = getPosition(e)[0];
        lstPageY = getPosition(e)[1];
        utils_1.addEvent(documentElement, MOVE_HANDLES, handleDrag);
        utils_1.addEvent(documentElement, UP_HANDLES, handleUp);
        if (containerProvider && !containerProvider.disabled.value) {
          referenceLineMap = utils_1.getReferenceLineMap(containerProvider, parentSize, id);
        }
      };
      vue_1.watch(dragging, function(cur, pre) {
        if (!pre && cur) {
          emit("drag-start", { x: x.value, y: y.value });
          setEnable(true);
          setDragging(true);
        } else {
          emit("drag-end", { x: x.value, y: y.value });
          setDragging(false);
        }
      });
      vue_1.onMounted(function() {
        var el = containerRef.value;
        if (!el)
          return;
        el.style.left = x + "px";
        el.style.top = y + "px";
        utils_1.addEvent(documentElement, DOWN_HANDLES, _unselect);
        utils_1.addEvent(el, DOWN_HANDLES, handleDown);
      });
      vue_1.onUnmounted(function() {
        if (!containerRef.value)
          return;
        utils_1.removeEvent(documentElement, DOWN_HANDLES, _unselect);
        utils_1.removeEvent(documentElement, UP_HANDLES, handleUp);
        utils_1.removeEvent(documentElement, MOVE_HANDLES, handleDrag);
      });
      return { containerRef };
    }
    exports.initDraggableContainer = initDraggableContainer;
    function initResizeHandle(containerProps, limitProps, parentSize, props, emit) {
      var setWidth = limitProps.setWidth, setHeight = limitProps.setHeight, setLeft = limitProps.setLeft, setTop = limitProps.setTop;
      var width = containerProps.width, height = containerProps.height, left = containerProps.left, top = containerProps.top, aspectRatio = containerProps.aspectRatio;
      var setResizing = containerProps.setResizing, setResizingHandle = containerProps.setResizingHandle, setResizingMaxWidth = containerProps.setResizingMaxWidth, setResizingMaxHeight = containerProps.setResizingMaxHeight, setResizingMinWidth = containerProps.setResizingMinWidth, setResizingMinHeight = containerProps.setResizingMinHeight;
      var parentWidth = parentSize.parentWidth, parentHeight = parentSize.parentHeight;
      var lstW = 0;
      var lstH = 0;
      var lstX = 0;
      var lstY = 0;
      var lstPageX = 0;
      var lstPageY = 0;
      var tmpAspectRatio = 1;
      var idx0 = "";
      var idx1 = "";
      var documentElement = document.documentElement;
      var resizeHandleDrag = function(e) {
        e.preventDefault();
        var _a = getPosition(e), _pageX = _a[0], _pageY = _a[1];
        var deltaX = _pageX - lstPageX;
        var deltaY = _pageY - lstPageY;
        var _deltaX = deltaX;
        var _deltaY = deltaY;
        if (props.lockAspectRatio) {
          deltaX = Math.abs(deltaX);
          deltaY = deltaX * tmpAspectRatio;
          if (idx0 === "t") {
            if (_deltaX < 0 || idx1 === "m" && _deltaY < 0) {
              deltaX = -deltaX;
              deltaY = -deltaY;
            }
          } else {
            if (_deltaX < 0 || idx1 === "m" && _deltaY < 0) {
              deltaX = -deltaX;
              deltaY = -deltaY;
            }
          }
        }
        if (idx0 === "t") {
          setHeight(lstH - deltaY);
          setTop(lstY - (height.value - lstH));
        } else if (idx0 === "b") {
          setHeight(lstH + deltaY);
        }
        if (idx1 === "l") {
          setWidth(lstW - deltaX);
          setLeft(lstX - (width.value - lstW));
        } else if (idx1 === "r") {
          setWidth(lstW + deltaX);
        }
        emit("resizing", {
          x: left.value,
          y: top.value,
          w: width.value,
          h: height.value
        });
      };
      var resizeHandleUp = function() {
        emit("resize-end", {
          x: left.value,
          y: top.value,
          w: width.value,
          h: height.value
        });
        setResizingHandle("");
        setResizing(false);
        setResizingMaxWidth(Infinity);
        setResizingMaxHeight(Infinity);
        setResizingMinWidth(props.minW);
        setResizingMinHeight(props.minH);
        utils_1.removeEvent(documentElement, MOVE_HANDLES, resizeHandleDrag);
        utils_1.removeEvent(documentElement, UP_HANDLES, resizeHandleUp);
      };
      var resizeHandleDown = function(e, handleType) {
        if (!props.resizable)
          return;
        e.stopPropagation();
        setResizingHandle(handleType);
        setResizing(true);
        idx0 = handleType[0];
        idx1 = handleType[1];
        if (props.lockAspectRatio) {
          if (["tl", "tm", "ml", "bl"].includes(handleType)) {
            idx0 = "t";
            idx1 = "l";
          } else {
            idx0 = "b";
            idx1 = "r";
          }
        }
        var minHeight = props.minH;
        var minWidth = props.minW;
        if (props.lockAspectRatio) {
          if (minHeight / minWidth > aspectRatio.value) {
            minWidth = minHeight / aspectRatio.value;
          } else {
            minHeight = minWidth * aspectRatio.value;
          }
        }
        setResizingMinWidth(minWidth);
        setResizingMinHeight(minHeight);
        if (props.parent) {
          var maxHeight = idx0 === "t" ? top.value + height.value : parentHeight.value - top.value;
          var maxWidth = idx1 === "l" ? left.value + width.value : parentWidth.value - left.value;
          if (props.lockAspectRatio) {
            if (maxHeight / maxWidth < aspectRatio.value) {
              maxWidth = maxHeight / aspectRatio.value;
            } else {
              maxHeight = maxWidth * aspectRatio.value;
            }
          }
          setResizingMaxHeight(maxHeight);
          setResizingMaxWidth(maxWidth);
        }
        lstW = width.value;
        lstH = height.value;
        lstX = left.value;
        lstY = top.value;
        var lstPagePosition = getPosition(e);
        lstPageX = lstPagePosition[0];
        lstPageY = lstPagePosition[1];
        tmpAspectRatio = aspectRatio.value;
        emit("resize-start", {
          x: left.value,
          y: top.value,
          w: width.value,
          h: height.value
        });
        utils_1.addEvent(documentElement, MOVE_HANDLES, resizeHandleDrag);
        utils_1.addEvent(documentElement, UP_HANDLES, resizeHandleUp);
      };
      vue_1.onUnmounted(function() {
        utils_1.removeEvent(documentElement, UP_HANDLES, resizeHandleUp);
        utils_1.removeEvent(documentElement, MOVE_HANDLES, resizeHandleDrag);
      });
      var handlesFiltered = vue_1.computed(function() {
        return props.resizable ? utils_1.filterHandles(props.handles) : [];
      });
      return {
        handlesFiltered,
        resizeHandleDown
      };
    }
    exports.initResizeHandle = initResizeHandle;
    function watchProps(props, limits) {
      var setWidth = limits.setWidth, setHeight = limits.setHeight, setLeft = limits.setLeft, setTop = limits.setTop;
      vue_1.watch(function() {
        return props.w;
      }, function(newVal) {
        setWidth(newVal);
      });
      vue_1.watch(function() {
        return props.h;
      }, function(newVal) {
        setHeight(newVal);
      });
      vue_1.watch(function() {
        return props.x;
      }, function(newVal) {
        setLeft(newVal);
      });
      vue_1.watch(function() {
        return props.y;
      }, function(newVal) {
        setTop(newVal);
      });
    }
    exports.watchProps = watchProps;
  }
});

// vite:dep-pre-bundle:external-conversion:D:/VsWorkSpace/personal-web/vite-project/node_modules/vue3-draggable-resizable/src/components/index.css
var components_exports = {};
import "D:/VsWorkSpace/personal-web/vite-project/node_modules/vue3-draggable-resizable/src/components/index.css";
var init_components = __esm({
  "vite:dep-pre-bundle:external-conversion:D:/VsWorkSpace/personal-web/vite-project/node_modules/vue3-draggable-resizable/src/components/index.css"() {
  }
});

// node_modules/vue3-draggable-resizable/src/components/Vue3DraggableResizable.js
var require_Vue3DraggableResizable = __commonJS({
  "node_modules/vue3-draggable-resizable/src/components/Vue3DraggableResizable.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    exports.ALL_HANDLES = void 0;
    var vue_1 = require_vue();
    var hooks_1 = require_hooks();
    init_components();
    var utils_1 = require_utils();
    exports.ALL_HANDLES = [
      "tl",
      "tm",
      "tr",
      "ml",
      "mr",
      "bl",
      "bm",
      "br"
    ];
    var VdrProps = {
      initW: {
        type: Number,
        "default": null
      },
      initH: {
        type: Number,
        "default": null
      },
      w: {
        type: Number,
        "default": 0
      },
      h: {
        type: Number,
        "default": 0
      },
      x: {
        type: Number,
        "default": 0
      },
      y: {
        type: Number,
        "default": 0
      },
      draggable: {
        type: Boolean,
        "default": true
      },
      resizable: {
        type: Boolean,
        "default": true
      },
      disabledX: {
        type: Boolean,
        "default": false
      },
      disabledY: {
        type: Boolean,
        "default": false
      },
      disabledW: {
        type: Boolean,
        "default": false
      },
      disabledH: {
        type: Boolean,
        "default": false
      },
      minW: {
        type: Number,
        "default": 20
      },
      minH: {
        type: Number,
        "default": 20
      },
      active: {
        type: Boolean,
        "default": false
      },
      parent: {
        type: Boolean,
        "default": false
      },
      handles: {
        type: Array,
        "default": exports.ALL_HANDLES,
        validator: function(handles) {
          return utils_1.filterHandles(handles).length === handles.length;
        }
      },
      classNameDraggable: {
        type: String,
        "default": "draggable"
      },
      classNameResizable: {
        type: String,
        "default": "resizable"
      },
      classNameDragging: {
        type: String,
        "default": "dragging"
      },
      classNameResizing: {
        type: String,
        "default": "resizing"
      },
      classNameActive: {
        type: String,
        "default": "active"
      },
      classNameHandle: {
        type: String,
        "default": "handle"
      },
      lockAspectRatio: {
        type: Boolean,
        "default": false
      }
    };
    var emits = [
      "activated",
      "deactivated",
      "drag-start",
      "resize-start",
      "dragging",
      "resizing",
      "drag-end",
      "resize-end",
      "update:w",
      "update:h",
      "update:x",
      "update:y",
      "update:active"
    ];
    var VueDraggableResizable = vue_1.defineComponent({
      name: "Vue3DraggableResizable",
      props: VdrProps,
      emits,
      setup: function(props, _a) {
        var emit = _a.emit;
        var containerProps = hooks_1.initState(props, emit);
        var provideIdentity = vue_1.inject("identity", Symbol());
        var containerProvider = null;
        if (provideIdentity === utils_1.IDENTITY) {
          containerProvider = {
            updatePosition: vue_1.inject("updatePosition"),
            getPositionStore: vue_1.inject("getPositionStore"),
            disabled: vue_1.inject("disabled"),
            adsorbParent: vue_1.inject("adsorbParent"),
            adsorbCols: vue_1.inject("adsorbCols"),
            adsorbRows: vue_1.inject("adsorbRows"),
            setMatchedLine: vue_1.inject("setMatchedLine")
          };
        }
        var containerRef = vue_1.ref();
        var parentSize = hooks_1.initParent(containerRef);
        var limitProps = hooks_1.initLimitSizeAndMethods(props, parentSize, containerProps);
        hooks_1.initDraggableContainer(containerRef, containerProps, limitProps, vue_1.toRef(props, "draggable"), emit, containerProvider, parentSize);
        var resizeHandle = hooks_1.initResizeHandle(containerProps, limitProps, parentSize, props, emit);
        hooks_1.watchProps(props, limitProps);
        return __assign(__assign(__assign(__assign({
          containerRef,
          containerProvider
        }, containerProps), parentSize), limitProps), resizeHandle);
      },
      computed: {
        style: function() {
          return {
            width: this.width + "px",
            height: this.height + "px",
            top: this.top + "px",
            left: this.left + "px"
          };
        },
        klass: function() {
          var _a;
          return _a = {}, _a[this.classNameActive] = this.enable, _a[this.classNameDragging] = this.dragging, _a[this.classNameResizing] = this.resizing, _a[this.classNameDraggable] = this.draggable, _a[this.classNameResizable] = this.resizable, _a;
        }
      },
      mounted: function() {
        if (!this.containerRef)
          return;
        this.containerRef.ondragstart = function() {
          return false;
        };
        var _a = utils_1.getElSize(this.containerRef), width = _a.width, height = _a.height;
        this.setWidth(this.initW === null ? this.w || width : this.initW);
        this.setHeight(this.initH === null ? this.h || height : this.initH);
        if (this.containerProvider) {
          this.containerProvider.updatePosition(this.id, {
            x: this.left,
            y: this.top,
            w: this.width,
            h: this.height
          });
        }
      },
      render: function() {
        var _this = this;
        return vue_1.h("div", {
          ref: "containerRef",
          "class": ["vdr-container", this.klass],
          style: this.style
        }, __spreadArrays([
          this.$slots["default"] && this.$slots["default"]()
        ], this.handlesFiltered.map(function(item) {
          return vue_1.h("div", {
            "class": [
              "vdr-handle",
              "vdr-handle-" + item,
              _this.classNameHandle,
              _this.classNameHandle + "-" + item
            ],
            style: { display: _this.enable ? "block" : "none" },
            onMousedown: function(e) {
              return _this.resizeHandleDown(e, item);
            },
            onTouchstart: function(e) {
              return _this.resizeHandleDown(e, item);
            }
          });
        })));
      }
    });
    exports["default"] = VueDraggableResizable;
  }
});

// node_modules/vue3-draggable-resizable/src/components/DraggableContainer.js
var require_DraggableContainer = __commonJS({
  "node_modules/vue3-draggable-resizable/src/components/DraggableContainer.js"(exports) {
    "use strict";
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    var vue_1 = require_vue();
    var utils_1 = require_utils();
    exports["default"] = vue_1.defineComponent({
      name: "DraggableContainer",
      props: {
        disabled: {
          type: Boolean,
          "default": false
        },
        adsorbParent: {
          type: Boolean,
          "default": true
        },
        adsorbCols: {
          type: Array,
          "default": null
        },
        adsorbRows: {
          type: Array,
          "default": null
        },
        referenceLineVisible: {
          type: Boolean,
          "default": true
        },
        referenceLineColor: {
          type: String,
          "default": "#f00"
        }
      },
      setup: function(props) {
        var positionStore = vue_1.reactive({});
        var updatePosition = function(id, position) {
          positionStore[id] = position;
        };
        var getPositionStore = function(excludeId) {
          var _positionStore = Object.assign({}, positionStore);
          if (excludeId) {
            delete _positionStore[excludeId];
          }
          return _positionStore;
        };
        var state = vue_1.reactive({
          matchedLine: null
        });
        var matchedRows = vue_1.computed(function() {
          return state.matchedLine && state.matchedLine.row || [];
        });
        var matchedCols = vue_1.computed(function() {
          return state.matchedLine && state.matchedLine.col || [];
        });
        var setMatchedLine = function(matchedLine) {
          state.matchedLine = matchedLine;
        };
        vue_1.provide("identity", utils_1.IDENTITY);
        vue_1.provide("updatePosition", updatePosition);
        vue_1.provide("getPositionStore", getPositionStore);
        vue_1.provide("setMatchedLine", setMatchedLine);
        vue_1.provide("disabled", vue_1.toRef(props, "disabled"));
        vue_1.provide("adsorbParent", vue_1.toRef(props, "adsorbParent"));
        vue_1.provide("adsorbCols", props.adsorbCols || []);
        vue_1.provide("adsorbRows", props.adsorbRows || []);
        return {
          matchedRows,
          matchedCols
        };
      },
      methods: {
        renderReferenceLine: function() {
          var _this = this;
          if (!this.referenceLineVisible) {
            return [];
          }
          return __spreadArrays(this.matchedCols.map(function(item) {
            return vue_1.h("div", {
              style: {
                width: "0",
                height: "100%",
                top: "0",
                left: item + "px",
                borderLeft: "1px dashed " + _this.referenceLineColor,
                position: "absolute"
              }
            });
          }), this.matchedRows.map(function(item) {
            return vue_1.h("div", {
              style: {
                width: "100%",
                height: "0",
                left: "0",
                top: item + "px",
                borderTop: "1px dashed " + _this.referenceLineColor,
                position: "absolute"
              }
            });
          }));
        }
      },
      render: function() {
        return vue_1.h("div", {
          style: { width: "100%", height: "100%", position: "relative" }
        }, __spreadArrays([
          this.$slots["default"] && this.$slots["default"]()
        ], this.renderReferenceLine()));
      }
    });
  }
});

// node_modules/vue3-draggable-resizable/src/index.js
var require_src = __commonJS({
  "node_modules/vue3-draggable-resizable/src/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    exports.__esModule = true;
    var Vue3DraggableResizable_1 = require_Vue3DraggableResizable();
    var DraggableContainer_1 = require_DraggableContainer();
    Vue3DraggableResizable_1["default"].install = function(app) {
      app.component(Vue3DraggableResizable_1["default"].name, Vue3DraggableResizable_1["default"]);
      app.component(DraggableContainer_1["default"].name, DraggableContainer_1["default"]);
      return app;
    };
    var DraggableContainer_2 = require_DraggableContainer();
    __createBinding(exports, DraggableContainer_2, "default", "DraggableContainer");
    exports["default"] = Vue3DraggableResizable_1["default"];
  }
});
export default require_src();
//# sourceMappingURL=vue3-draggable-resizable.js.map
